---
layout: default_no_header
title: Экзамен
---

> Пошел на экзамен. Пожелайте мне удачи, пожалуйста. А то они не сдадут, и мне придется опять принимать.

## Структура экзамена

Перед теоретическими вопросами вам будут предоставлены 2 задачи на выбор. Вы можете выполнить обе или только одну.
После ознакомления вы будете приглашены по очереди на сдачу теории. Перед и после сдачи теории можно спокойно решать задачу.
Как задача будет решена, присылайте на почту, крайний срок сдачи 19:15.


## Задачи

### Оптимизация

Требуется оптимизировать **по памяти** алгоритм/программу, время выполнения не имеет значения, а также найти места, в которых может возникнуть ошибка. 
Алгоритм описывает симуляцию хода в игре "Жизнь" ([Conway's Game of Life](https://ru.wikipedia.org/wiki/%D0%98%D0%B3%D1%80%D0%B0_%C2%AB%D0%96%D0%B8%D0%B7%D0%BD%D1%8C%C2%BB)),
но только один ход. Размер поля и его содержимое может изменяться, изначальное поле хранится в переменной `field`. После выполнения алгоритма поле должно обновится.

```js
field = [[0, 0, 0, 1, 1, 0, 0, 1, 0, 1],
         [0, 1, 0, 0, 0, 1, 0, 1, 0, 1],
         ...
         [0, 0, 0, 0, 1, 0, 0, 1, 0, 0]]
field_size = (len(field), len(field[0]))
new_field = []

for (i = 0; i < field_size[0]; i++) {
    new_field.add([])
    for (j = 0; j < field_size[1]; j++) {
        new_field[i].add(0)
    }
}

for (i = 0; i < field_size[0]; i++) {
    for (j = 0; j < field_size[1]; j++) {
        neighbors = [field[i][j-1],
                     field[i][j+1],
                     field[i-1][j],
                     field[i+1][j],
                     field[i-1][j-1],
                     field[i+1][j-1],
                     field[i-1][j+1],
                     field[i+1][j+1]]
        for (k = 0; k < 8; k++) {
            if (neighbors[k] == 1)  {
                sum_neighbors += 1
            }
        }
        if (field[i][j] == 1 && (sum_neighbors == 2 || sum_neighbors == 3)) {
            new_field[i][j] = 1
        } else if (field[i][j] == 0 && sum_neighbors == 3) {
            new_field[i][j] = 1
        } else {
            new_field[i][j] = 0
        }
    }
}

for (i = 0; i < field_size[0]; i++) {
    for (j = 0; j < field_size[1]; j++) {
        field[i][j] = new_field[i][j]
    }
}
```

Чем лучше оптимизировано, тем выше оценка. Дополнительные упрощения возможны. Алгоритм можно описать на другом языке программирования,
но в таком случае структуру программы менять нельзя. Если не понимаете как оптимизировать или почему цифры плохо, то лучше заняться проектированием устройств.

### Проектирование устройства

Требуется спроектировать устройство, которое позволяет проверять числа на принадлежность промежутку. 
Данное устройство имеет 5 входов для разрядов чисел, 3 входа для управления и 2 выхода. Необязательно использовать все входы управления.

Схема работы устройства:

- При подаче сигнала считывания нижней границы на управляющий вход (как закодировать выбираете вы) устройство считывает нижнюю границу
- При подаче сигнала считывания верхней границы устройство считывает верхнюю границу
- При подаче сигнала вывода результата устройство считывает число для сравнения и возвращает результат на первый вход (1 если принадлежит и 0 если нет)
- Если был подан сигнал вывода результата, но хотя бы одной границы нет, то устройство должно вернуть на второй выход 1
- Если введенная нижняя (верхняя) граница больше (меньше) другой границы, то устройство должно вернуть на второй выход 1
- Сравнение на принадлежность промежутку не строгое: `<число> ∈ [<нижняя>, <верхняя>]`
- После считывания границы сохраняются, даже если они неправильные.

<img class="img-small" src="{{site.baseurl}}/resources/exam.png"/>

## Теория и вопросы

В каждом пункте указана тема, которую требуется раскрыть. А также вопросы, на которые нужно обязательно дать ответ.

1. Система счисления. Какие бывают системы счисления? Как происходит в них арифметика?
2. Информация. Что такое количество информации и как оно представляется?
3. Обратный и дополнительный коды. Зачем они нужны и как происходит в них арифметика?
4. Логические операции. Что такое бинарная операция? В чем её отличие от логической операции над бинарным объектом?
5. Логические операции. Какие свойства имеют логические операции?
6. Логический базис. Можно ли определить избыточность или минимальность базиса и как?
7. Логический базис. Как можно привести функцию из одного базиса в другой?
8. Нормальные формы логических функций. Что это такое и зачем нужно?
9. Триггеры. Что такое состояние триггера? Что такое функция перехода триггеров?
10. Автоматы. Чем описываются автоматы? Является ли простая логическая функция автоматом?
11. Автоматы и алгоритмы. В чем связь алгоритмов и автоматов? Что позволяют описать состояния автоматов в алгоритмизации?
12. Двоично-десятичный код. Как проходит в нем арифметика? Какие кодировки вам известны и в чем они похожи?

**Удачи!**